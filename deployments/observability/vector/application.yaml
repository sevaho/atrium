---
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: vector
  namespace: argocd
spec:
  project: default
  source:
    repoURL: https://github.com/sevaho/atrium
    path: deployments/observability/vector
    targetRevision: HEAD
    helm:
      releaseName: vector
      valuesObject:
        vector:
          env:
            - name: AWS_ACCESS_KEY_ID
              valueFrom:
                secretKeyRef:
                  name: vector-data-secret
                  key: AWS_ACCESS_KEY_ID
            - name: AWS_SECRET_ACCESS_KEY
              valueFrom:
                secretKeyRef:
                  name: vector-data-secret
                  key: AWS_SECRET_ACCESS_KEY
          podAnnotations:
            vector.dev/exclude: 'true'
          role: Agent
          service:
            enabled: false
          tolerations:
            - effect: NoSchedule
              key: node-role.kubernetes.io/controlplane
              operator: Exists
            - effect: NoExecute
              key: node-role.kubernetes.io/etcd
              operator: Exists
          customConfig:
            data_dir: "/var/lib/vector"
            api:
              enabled: false
            sources:
              kubernetes:
                type: kubernetes_logs

            transforms:
              remap_kubernetes_otel:
                type: "remap"
                inputs: [kubernetes]
                source: |-
                  parsed_timestamp, err = parse_timestamp(.timestamp, "%Y-%m-%dT%H:%M:%S.%fZ")
                  if err != null {
                      log("Unable to parse timestamp, taking now(): " + err, level: "error")
                      .timestamp_nanos = to_unix_timestamp(now(), unit: "nanoseconds")

                  } else {
                      .timestamp_nanos = to_unix_timestamp(parsed_timestamp, unit: "nanoseconds")
                  }
                  .resource_attributes = .kubernetes
                  .service_name = .kubernetes.pod_name

                  .attributes = .kubernetes
                  .resource_attributes.file = .file

                  .body.stream = .stream
                  .body.message = .message

                  parsed_json, err = parse_json(.message)
                  if err != null {
                      if .stream == "stderr" {
                        .severity_text = "error"
                      } else {
                        .severity_text = "unknown"
                      }
                  } else {
                      # .body.message = parsed_json.message ||
                      #                 parsed_json.msg ||
                      #                 .message

                      .body.stream = parsed_json.stream ||
                                     .stream

                      # Extract log level from multiple possible fields
                      levelinfo = parsed_json.level ||
                                  parsed_json.levelname ||
                                  parsed_json.severity ||
                                  parsed_json.log_level ||
                                  null

                      if levelinfo == null {
                          .severity_text = "unknown"
                      } else if includes(["emerg", "fatal", "crit", "alert", "FATAL", "critical", "ALERT", "CRITICAL", "0", "1", "2"], levelinfo) {
                          .severity_text = "critical"
                      } else if includes(["err", "eror", "error", "ERR", "ERROR", "3"], levelinfo) {
                          .severity_text = "error"
                      } else if includes(["warn", "warning", "WARN", "WARNING", "4"], levelinfo) {
                          .severity_text = "warning"
                      } else if includes(["info", "INFO", "notice", "NOTICE", "5", "6"], levelinfo) {
                          .severity_text = "info"
                      } else if includes(["debug", "DEBUG", "7"], levelinfo) {
                          .severity_text = "debug"
                      } else {
                          .severity_text = "unknown"
                      }
                  }

                  .id = uuid_v7()

                  del(.kubernetes)
                  del(.timestamp)
                  del(.source_type)
                  del(.stream)
                  del(.file)


            sinks:
              s3:
                type: aws_s3
                inputs:
                  - kubernetes
                endpoint: ${AWS_S3_ENDPOINT}
                bucket: ${AWS_S3_BUCKET}
                region: ${AWS_S3_REGION}
                key_prefix: vector/logs/kubernetes/hetzner/year=%Y/month=%m/day=%d
                encoding:
                  codec: json
              quickwit_logs:
                type: "http"
                method: "post"
                inputs:
                  - remap_kubernetes_otel
                encoding:
                  codec: json
                framing:
                  method: "newline_delimited"
                uri: "http://quickwit-indexer:7280/api/v1/vector-otel-0.8/ingest"

  destination:
    server: "https://kubernetes.default.svc"
    namespace: observability
  syncPolicy:
    automated:
      prune: false
      selfHeal: false
  info:
  - name: releasenotes
    value: https://github.com/vectordotdev/vector/releases
  - name: values.yaml
    value: https://github.com/vectordotdev/helm-charts/blob/develop/charts/vector/values.yaml
---
apiVersion: v1
data:
  AWS_ACCESS_KEY_ID: ${AWS_S3_ACCESS_KEY::BASE64}
  AWS_SECRET_ACCESS_KEY: ${AWS_S3_SECRET_KEY::BASE64}
kind: Secret
metadata:
  name: vector-data-secret
  namespace: observability
type: Opaque
